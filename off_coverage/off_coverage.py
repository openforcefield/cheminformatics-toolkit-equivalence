# Identify a subset of compound records which cover the same range of
# feature space as a larger data set.

# Features are identified using warnings and error messages from
# RDKit, OEChem, and OpenFF, and from tests and cross-testing based on
# those packages.

# In addition, features may be generated by code coverage of the
# internal paths used by the test functions.

## General approach
#
# 1) Identify all features for each molecule
# 2) Find a minimal set which covers the features
#  - use Z3 to find the coverage
#  - allow weighting based on specified factors

## Example:
#
# % python off_coverage.py xcompare --trace on MiniDrugBank.sdf -o MiniDrugBank.feats
# % python off_coverage.py z3_create MiniDrugBank.feats -o MiniDrugBank.smt
# % z3 MiniDrugBank.smt > MiniDrugBank.out
# % python off_coverage.py z3_decode MiniDrugBank.out

## Overview
#
# off_coverage.py openeye dataset.{sdf,smi}
#   - use OpenEye's OEChem and OpenFF to identify features
# off_coverage.py rdkit dataset.{sdf,smi}
#   - use RDKit and OpenFF to identify features
# off_coverage.py xcompare dataset.{sdf,smi} -o x.feats
#   - cross-compare the OpenFF's RDKit and OEChem wrappers
# off_coverage.py merge x.feats y.feats -o z.feats
#   - merge multiple datasets into one
# off_coverage.py z3_create x.feats -o x.smt
#   - create an SMT-formatted input file for Z3
#      Used as: z3 z.smt > x.out
# off_coverage.py z3_decode x.out
#   - extract the model information from the Z3 output

## MIT LICENSE

# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation files
# (the "Software"), to deal in the Software without restriction,
# including without limitation the rights to use, copy, modify, merge,
# publish, distribute, sublicense, and/or sell copies of the Software,
# and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:

# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.




import argparse
import ast
import contextlib
import gzip
import hashlib
import io
import os
import re
import sys
from collections import Counter, defaultdict

__version__ = "0.9"
__version_info__ = (0, 9, 0)
__author__ = "Andrew Dalke <dalke@dalkescientific.com>"
__funding__ = "The Open Force Field Initiative"

# I use 'id' for molecule ids. If I use 'id' without first defining
# it, I get Python's "id()" builtin instead, which can be printed out
# using the default object repr(). I don't want that. Instead,
# use a module 'id' which can't be repr()'ed.

class ReprComplain:
    def __repr__(self):
        raise AssertionError("wrong id")
id = ReprComplain()

# I want the code to run even if RDKit or OpenEye isn't available.  I
# could put imports in every function, which is a a bit tedious.
# Instead, for a few places I'll refer to a module variable which is
# either the correct module, or something which complains if used.

class MissingModule:
    def __init__(self, module_name, errmsg):
        self.module_name = module_name
        self.errmsg = errmsg
    def __getattr__(self, name):
        raise ImportError(f"Could not import {self.module_name}: {self.errmsg}")

try:
    from openeye import oechem
except ImportError as err:
    oechem = MissingModule("openeye.oechem", str(err))
    
try:
    from openeye import oegraphsim
except ImportError as err:
    oechem = MissingModule("openeye.oegraphsim", str(err))
    
try:
    from rdkit import Chem
except ImportError as err:
    Chem = MissingModule("rdkit.Chem", str(err))


#### Some argparse dispatch helper functions

# If no "feature_flags" options are set then set the indicated default
# features.
    
# This says that given option is one of the default features.

def add_default_feature_argument(parser, *args, **kwargs):
    arg = parser.add_argument(*args, **kwargs)
    dest = arg.dest
    parser._defaults["feature_flags"].append(dest)
    parser._defaults["default_feature_flags"].append(dest)
    return arg

# This says that given option is NOT one of the default features.
# (If selected then the default features will not be selected.)

def add_feature_argument(parser, *args, **kwargs):
    arg = parser.add_argument(*args, **kwargs)
    dest = arg.dest
    parser._defaults["feature_flags"].append(dest)
    return arg

#### line coverage tracer

def hexdigest(s):
    ## Uncomment for debugging
    #return f"<{s.replace(' ', '_')}>"
    return hashlib.sha256(s.encode("ascii")).hexdigest()

# Each function call gets its own trace.
class PerFunctionTracer:
    def __init__(self, tracer_class):
        self.tracer_class = tracer_class
        self.tracers = []

    def clear(self):
        del self.tracers[:]

    def get_local_trace(self, func_name):
        tracer = self.tracer_class()
        self.tracers.append((func_name, tracer))
        return tracer.local_trace

    def get_signatures(self):
        signatures = set()
        for (func_name, tracer) in self.tracers:
            #print("Func:", k)
            s = f"func: {func_name} {tracer.get_signature()}"
            #signatures.add(hexdigest(s))
            signatures.add(s)
            
        return signatures

    def has_trace(self):
        return any(tracer.has_trace() for tracer in self.tracers.values())
    
    
class PerModuleTracer:
    def __init__(self, tracer_class):
        self.tracer_class = tracer_class
        self.tracer = tracer_class()

    def clear(self):
        self.tracer = self.tracer_class()
        
    def get_local_trace(self, func_name):
        return self.tracer.local_trace

    def get_signatures(self):
        return set([self.tracer.get_signature()])
    
    def has_trace(self):
        return self.tracer.has_trace()


##

class TraceLineCoverage:
    def __init__(self):
        self.linenos = set()
        
    def get_signature(self):
        s = str(sorted(self.linenos)).replace(" ", "")
        s = f"<cover: {s}>"
        return s
        #return hexdigest(f"cover: {s}")

    def local_trace(self, frame, event, arg):
        lineno = None
        if event == "line":
            lineno = frame.f_lineno
        elif event == "return":
            lineno = -2*frame.f_lineno - 1
        elif event == "exception":
            lineno = -2*frame.f_lineno - 2

        if lineno is not None:
            self.linenos.add(lineno)

class TraceLineSequence:
    def __init__(self):
        self.linenos = []

    def local_trace(self, frame, event, arg):
        lineno = None
        if event == "line":
            lineno = frame.f_lineno
        elif event == "return":
            lineno = -2*frame.f_lineno - 1
        elif event == "exception":
            lineno = -2*frame.f_lineno - 2
            
        if lineno is not None:
            self.linenos.append(lineno)

    def get_signature(self):
        s = str(self.linenos).replace(" ", "")
        s = f"<seq: {s}>"
        return s
        #return hexdigest(f"seq: {s}")

class TraceLinePairs:
    def __init__(self):
        self.pairs = set()
        self._prev_lineno = 0
        
    def local_trace(self, frame, event, arg):
        lineno = None
        if event == "line":
            lineno = frame.f_lineno
        elif event == "return":
            lineno = -2*frame.f_lineno - 1
        elif event == "exception":
            lineno = -2*frame.f_lineno - 2
            
        if lineno is not None:
            self.pairs.add((self._prev_lineno, lineno))
            self._prev_lineno = lineno

    def get_signature(self):
        s = str(sorted(self.pairs)).replace(" ", "")
        s = f"<pairs: {s}>"
        return s
        #return hexdigest(f"pairs: {s}")
    

class ToolkitTracer:
    def __init__(self, module_names, module_tracer_class, function_tracer_class):
        self.module_tracer_class = module_tracer_class
        self.function_tracer_class = function_tracer_class
        
        self.module_names = module_names
        self.module_tracers = {}
        self._can_trace = {}
        
    def global_trace(self, frame, event, arg):
        if event != "call":
            return None
        
        module_name = frame.f_globals.get("__name__", None)
        if module_name is None:
            return None

        can_trace = self._can_trace.get(module_name, None)
        if can_trace is None:
            if module_name in self.module_names:
                can_trace = self._can_trace[module_name] = True
            else:
                # check for prefix names
                ## with open("/dev/ttys005", "w") as f:
                ##     print(module_name, file=f)
                for name in self.module_names:
                    if name[-1:] == "." and module_name.startswith(name):
                        can_trace = self._can_trace[module_name] = True
                        break
                else:
                    can_trace = self._can_trace[module_name] = False

        if can_trace:
            module_tracer = self.module_tracers.get(module_name, None)
            if module_tracer is None:
                module_tracer = self.module_tracer_class(self.function_tracer_class)
                self.module_tracers[module_name] = module_tracer
                
            func_name = frame.f_code.co_name
            return module_tracer.get_local_trace(func_name)

    def get_signatures(self):
        signatures = set()
        for module_name, module_tracer in self.module_tracers.items():
            for sig in module_tracer.get_signatures():
                s = f"<mod: {module_name} {sig}>"
                # s = hexdigest(s)
                signatures.add(s)
        return signatures

    def clear(self):
        self.module_tracers.clear()

    def __enter__(self):
        self.clear()
        sys.settrace(self.global_trace)

    def __exit__(self, *args):
        sys.settrace(None)

    def add_features(self, state):
        if self.module_tracers:
            for sig in self.get_signatures():
                digest = hexdigest(sig)
                state.add_feature(f"trace_{digest}", sig)

    @contextlib.contextmanager
    def using_state(self, state):
        self.clear()
        sys.settrace(self.global_trace)
        try:
            yield
        finally:
            sys.settrace(None)
            self.add_features(state)

class NullTracer:
    def __enter__(self):
        return self
    
    def __exit__(self, *args):
        pass
    
    def add_features(self, state):
        pass

    def using_state(self, state):
        return self

_trace_options = {
    "func-cover": (PerFunctionTracer, TraceLineCoverage),
    "func-sequence": (PerFunctionTracer, TraceLineSequence),
    "func-pairs": (PerFunctionTracer, TraceLinePairs),
    
    "mod-cover": (PerModuleTracer, TraceLineCoverage),
    "mod-sequence": (PerModuleTracer, TraceLineSequence),
    "mod-pairs": (PerModuleTracer, TraceLinePairs),
    }

_trace_options["on"] = _trace_options["mod-cover"]
    
def get_tracer(trace_type=None):
    module_names = set(["openff.", "toolkit.tests."])
    
    if trace_type is None or trace_type == "off":
        return NullTracer()
    try:
        module_tracer_class, function_tracer_class = _trace_options[trace_type]
    except KeyError:
        raise ValueError("unknown trace type")

    return ToolkitTracer(module_names, module_tracer_class, function_tracer_class)

# Experimental. Has quadradic behaviour.
## @contextlib.contextmanager
## def one_shot(filename, id, trace_type="mod-pairs"):
##     tracer = get_tracer(trace_type)
## 
##     description_filename = filename + ".description"
##     if os.path.exists(description_filename):
##         descriptions = load_descriptions(description_filename)
##     else:
##         descriptions = {}
##    
##     with open(filename, "a") as outfile:
##         with open(description_filename, "a") as description_file:
##                 description_logger = DescriptionLogger(description_file, set(descriptions))
##                 state = State(id, None, get_reporter(quiet=True),
##                                       description_logger = description_logger)
##                 
##                 with tracer.using_state(state):
##                     yield
##                     
##         write_features(outfile, id, state.features)

def open_call_coverage(filename, trace_type="func-pairs", append=False):
    tracer = get_tracer(trace_type)
    
    description_filename = filename + ".description"
    if append and os.path.exists(description_filename):
        seen = set(load_descriptions(description_filename))
    else:
        seen = set()

    if append:
        flag = "a"
    else:
        flag = "w"
    outfile = open(filename, flag)
    try:
        description_file = open(description_filename, flag)
    except:
        outfile.close()
        raise
    description_logger = DescriptionLogger(description_file, seen)

    return CallCoverage(outfile, description_file, description_logger, tracer)

class CallCoverage:
    def __init__(self, outfile, description_file, description_logger, tracer):
        self.outfile = outfile
        self.description_file = description_file
        self.description_logger = description_logger
        self.tracer = tracer

    def close(self):
        self.outfile.close()
        self.description_file.close()

    def __enter__(self):
        return self
    def __exit___(self, *args):
        self.close()

    def __del__(self):
        self.close()
        
    @contextlib.contextmanager
    def record(self, id):
        state = State(id, None, get_reporter(quiet=True), description_logger = self.description_logger)
        with self.tracer.using_state(state):
            yield
        write_features(self.outfile, id, state.features)
        

def add_trace_argument(parser):
    parser.add_argument(
        "--trace",
        metavar = "NAME",
        choices = (
            "on",
            "func-cover", "func-sequence", "func-pairs",
            "mod-cover", "mod-sequence", "mod-pairs",
            "off",
            ),
        default = "off",
        help = "trace option",
        )

#### Description logger

class DescriptionLogger:
    def __init__(self, outfile, seen=None):
        self.outfile = outfile
        if seen is None:
            self._seen = set()
        else:
            self._seen = set(seen)
    
    def add(self, feature, description):
        if feature not in self._seen:
            self._seen.add(feature)
            self.outfile.write(f"{feature}\t{description}\n")
            self.outfile.flush()

def get_description_logger(parser, filename):
    if filename is None:
        return None
    try:
        outfile = open(filename, "w")
    except OSError as err:
        parser.error(f"Cannot open --description file: {err}")
    return DescriptionLogger(outfile)

def load_descriptions(filename):
    descriptions = {}
    with open(filename) as infile:
        for lineno, line in enumerate(infile, 1):
            left, tab, right = line.rstrip("\n").partition("\t")
            if tab != "\t":
                raise AssertionError((filename, lineno, line))
            descriptions[left] = right
    return descriptions

####

import re

_valid_name_pat = re.compile("[A-Za-z_][A-Za-z0-9_]*$")    

TEST_PATTERNS = """

tag * 0
tag <specified_chiral_atoms> 1
tag <unspecified_chiral_atoms> 2


pattern triple_bond *#* limit 10
pattern double_bond *=* unique
pattern CO [#6]~[#8] limit 1
pattern unspecified_chiral_atoms <unspecified_chiral_atoms>

pattern prochiral_carbon [2#6]

#tag * 0
#tag <specified_chiral_atoms> 2

pattern chiral_carbon [2#6]

feature double_bond if double_bond
feature double_bond_3_9 if 3 <= double_bond <= 9
feature triple_bond if triple_bond

feature prochiral_carbon if prochiral_carbon
feature chiral_carbon if chiral_carbon

"""

STEREO_PATTERNS = """

## Set all isotopes to 0
tag * 0

tag <unspecified_chiral_atoms> 1
tag <specified_chiral_atoms> 2


## Undefined tetrahedral center
# C(Cl)(F)(Br)C
pattern undef_X4_center [1X4](-*)(-*)(-*)-*
feature undef_X4_center if undef_X4_center

## Undefined C=C double bond
# C(F)=C(Cl) 
pattern undef_CdC <undef_CdC>
feature undef_CdC if undef_CdC

## Undefined stereocenter, defined stereobond
# C\C(F)=C(/F)CC(C)(Cl)Br
pattern def_CdC_undef_stereo <def_CdC_undef_stereo>
feature def_CdC_undef_stereo if def_CdC_undef_stereo

## Defined stereocenter, undefined stereobond
# CC(F)=C(F)C[C@@](C)(Cl)Br
pattern undef_CdC_def_stereo <undef_CdC_def_stereo>
feature undef_CdC_def_stereo if undef_CdC_def_stereo

## Defined stereocenter, defined stereobond
# C\C(F)=C(/F)C[C@@](C)(Cl)Br
pattern def_CdC_def_stereo <def_CdC_def_stereo>
feature def_CdC_def_stereo if def_CdC_def_stereo

## Undefined imine
# CN=C(F)C

# From Open Babel:
#  nitrogen is not part of an amidelike structure, nor of an aromatic ring, but
#  can be part of an aminal or similar

pattern def_imine [NX2;$([N][#6]),$([NH]);!$([N][CX3]=[#7,#8,#15,#16])]=[2CX3;$([CH2]),$([CH][#6]),$([C]([#6])[#6])]
feature def_imine if def_imine

pattern undef_imine [NX2;$([N][#6]),$([NH]);!$([N][CX3]=[#7,#8,#15,#16])]=[1CX3;$([CH2]),$([CH][#6]),$([C]([#6])[#6])]
feature undef_imine if undef_imine

## Undefined primary imine
# N=C(F)C

## XXX TODO

## Undefined pyrimidal nitrogen
# N(Cl)(F)C

pattern undef_N_X3 [1#7X3](-*)(-*)-*
feature undef_N_X3 if undef_N_X3

## tetrahedral phosphate with one protonated oxygen
# CP(O)(=O)N

pattern undef_PX4wOH [1#14X4](-*)(-*)-*
feature undef_PX4wOH if undef_PX4wOH


### From Open Babel:
##   Amide: [CX3;$([R0][#6]),$([H1R0])](=[OX1])[#7X3;$([H2]),$([H1][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]
##   # does not hit lactames

## keto-form of amide bond
# CNC(C)=O
pattern undef_keto_amide [1CX3;$([R0][#6]),$([H1R0])](=[OX1])-[#7X3;$([H2]),$([H1]-[#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]


## enol-form of amide bond
# CN=C(C)O
pattern undef_enol_amide [1CX3;$([R0][#6]),$([H1R0])](-[OH1])=[#7X2;$([H1]),$([H0][#6;!$(C=[O,N,S])]),$([#7]([#6;!$(C=[O,N,S])])[#6;!$(C=[O,N,S])])]

feature undef_keto_amide if undef_keto_amide


## oximium
# C(=[O+][H])C

## ?
# N(C)(CC)(CCC)=O

## trivalent N in 3-membered ring
# C[C@H]1CN1C

## trivalent N in 3-membered ring (1 hydrogen)
# C[C@H]1CN1

## trivalent phosphorous
# [H]c1c(c(c(c(c1[H])[H])P2C(=C3C(=C2c4c(c(c(c(n4)[H])[H])[H])[H])C(C(C(C3([H])[H])([H])[H])([H])[H])([H])[H])c5c(c(c(c(n5)[H])[H])[H])[H])[H])[H]

## thione
# CCS(=O)C


"""

def check_valid_name(name, stop):
    m = _valid_name_pat.match(name)
    if m is None:
        stop(f"invalid name {name!r}")
        
def check_feature_expr(filename, lineno, feature_expr, seen_patterns, stop):
    try:
        node = ast.parse(feature_expr, mode="eval")
    except SyntaxError as err:
        stop(f"cannot parse the feature expression {feature_expr!r} at line {lineno}: {err}")
        
    for subnode in ast.walk(node):
        if isinstance(subnode, ast.Name):
            name = subnode.id
            if name not in seen_patterns:
                stop(f"Feature expression uses undefined pattern {name!r} at line {lineno}")

    if filename is None:
        where = f":{lineno}"
    else:
        where = f"{filename}:{lineno}"
    return compile(feature_expr, where, "eval")

# Work-in-progress
# Need to support and distinguish between SMARTS and SMILES patterns

class PatternDefs:
    def __init__(self, tags, patterns, features):
        self.tags = tags
        self.patterns = patterns
        self.features = features

    def __repr__(self):
        return f"PatternDefs({self.tags}, {self.patterns}, {self.features})"

def parse_pattern_definitions(infile, filename):
    def stop(msg):
        raise ValueError(f"{msg} at line {lineno}")

    tags = []
    
    seen_patterns = dict()
    patterns = []

    seen_features = dict()
    features = []
    
    for lineno, line in enumerate(infile, 1):
        line = line.strip()
        # skip blank lines and comments
        if not line or line[:1] == "#":
            continue

        terms = line.split()
        num_terms = len(terms)

        if terms[0] == "tag":
            if num_terms != 3:
                stop("invalid 'tag' definition")
            _, tag_pattern, tag_isotope_s = terms
            try:
                tag_isotope = int(tag_isotope_s)
            except ValueError:
                stop(
                    f"expected integer isotope: {tag_isotope_s!r}"
                    )
            if not (0 <= tag_isotope  <= 300):
                stop(
                    f"expected isotope out of range [0, 300]: {tag_isotope!r}"
                    )
            tags.append( (lineno, tag_pattern, tag_isotope) )
            continue
        
        
        if terms[0] == "pattern":
            if num_terms < 3:
                stop("invalid 'pattern' definition")
            pattern_name = terms[1]
            if pattern_name in seen_patterns:
                stop(
                    f"Duplicate pattern {pattern_name!r}: "
                    f"lines {seen_patterns[pattern_name]} and {lineno}")
            seen_patterns[pattern_name] = lineno
            
            check_valid_name(pattern_name, stop)
            pattern_smarts = terms[2]
            pattern_options = []
            
            i = 3
            while i < num_terms:
                term = terms[i]
                if term == "limit":
                    if i + 1 == num_terms:
                        stop("missing value after 'limit'")
                    limit = terms[i+1]
                    if not limit.isdigit():
                        stop(f"limit must be an integer: {limit!r}")
                    pattern_options.append(("limit", int(limit)))
                    i += 2
                elif term == "unique":
                    pattern_options.append(("unique", 1))
                    i += 1
                else:
                    stop(f"unsupported pattern option: {term!r}")
        
            patterns.append(
                (lineno, pattern_name, pattern_smarts, pattern_options)
                )
            continue
    
        if terms[0] == "feature":
            if num_terms < 4:
                stop("invalid 'feature' definition")
            feature_name = terms[1]
            if feature_name in seen_features:
                stop(
                    f"Duplicate feature {feature_name!r}: "
                    f"lines {seen_features[feature_name]} and {lineno}")
            seen_features[feature_name] = lineno

            check_valid_name(feature_name, stop)

            if terms[2] != "if":
                stop("Must have 'if' after the feature name")

            _, _, _, feature_expr = line.split(None, 3)
            code = check_feature_expr(filename, lineno, feature_expr, seen_patterns, stop)

            features.append(
                (lineno, feature_name, feature_expr, code),
                )
            continue

        stop(f"cannot parse pattern format line: {line!r}")
        
    return PatternDefs(tags, patterns, features)


def load_pattern_defs(filename):
    if filename == "<test>":
        f = io.StringIO(TEST_PATTERNS)
    elif filename == "<stereo>":
        f = io.StringIO(STEREO_PATTERNS)
    else:
        f = open(filename)
    try:
        return parse_pattern_definitions(f, filename)
    finally:
        f.close()

        
####

def die(msg):
    sys.stderr.write(msg + "\n")
    raise SystemExit(99)

#### Output

def open_output(filename):
    if filename is None:
        return sys.stdout
    else:
        return open(filename, "w")
    

def write_features(outfile, id, features):
    terms = " ".join(sorted(features))
    outfile.write(f"{id}\t{terms}\n")


### Capture stderr (used to get RDKit warnings)
@contextlib.contextmanager
def capture_stderr():
    orig = sys.stderr
    f = io.StringIO()
    msgs = []
    sys.stderr = f
    try:
        yield msgs
    finally:
        sys.stderr = orig
        s = f.getvalue()
        if s:
            msgs.extend(s.splitlines())

def add_id_tag_argument(p):
    p.add_argument(
        "--id-tag", 
        help = "location of the id tag (default: use the title line)")

def add_default_argument(p):
    p.add_argument(
        "--default",
        action = "store_true",
        help = "use all of the default tools (plus any other ones you might specify)")

def add_quiet_argument(p):
    p.add_argument(
        "--quiet", "-q",
        action = "store_true",
        help = "do not display status message",
        )
    
def add_description_argument(p):
    p.add_argument(
        "--description", "-D",
        metavar = "FILENAME",
        help = "write feature descriptions to the named file",
        )
    
def add_output_argument(p):
    p.add_argument(
        "--output", "-o",
        help = "output filename (default: stdout)")
    
def add_filename_argument(p):
    p.add_argument(
        "filename",
        help = "structure file (SMILES or SDF)",
        )

####

class FeatureTool:
    @staticmethod
    def add_arguments(parser):
        pass

    @staticmethod
    def initialize(parser, args):
        # return None or a callable(mol, features)
        return None

    def add_features(self, state):
        pass

class FilterTool:
    @staticmethod
    def add_arguments(parser):
        pass

    @staticmethod
    def initialize(parser, args):
        # return None or a callable(mol, features)
        return None

    def at_start(self, state):
        return False

    def at_end(self, state):
        return False

class State:
    def __init__(self, id, mol, reporter, features=None, description_logger=None):
        self.id = id
        self.mol = mol
        self.reporter = reporter
        if features is None:
            features = set()
        self.features = features
        self.description_logger = description_logger
        self.cache = {}

    def add_feature(self, feature, description=None):
        self.features.add(feature)
        if description is not None and self.description_logger is not None:
            self.description_logger.add(feature, description)

class Reporter:
    def status(self, msg):
        sys.stderr.write(f"{msg}\n")
        sys.stderr.flush()
    
    def unexpected_error(self, id, msg):
        sys.stderr.write(f"Unexpected error in id {id!r} -- {msg}\n")
        
    def skip(self, id, msg):
        sys.stderr.write(f"Skipping id {id!r} -- {msg}\n")

class QuietReporter:
    def status(self, msg):
        pass

    def unexpected_error(self, id, msg):
        pass
        
    def skip(self, id, msg):
        pass

def get_reporter(quiet):
    if quiet:
        return QuietReporter()
    else:
        return Reporter()
    
########## Generic tools

class SeenIdsFilterTool(FilterTool):
    @staticmethod
    def add_arguments(parser):
        parser.add_argument(
            "--ids",
            metavar = "FILENAME",
            help = "only process (or exclude) ids in the first column of the named file",
            )
        parser.add_argument(
            "--exclude-ids",
            action = "store_true",
            help = "only process ids not in the first column of the named file"
            )
            
    @staticmethod
    def initialize(parser, args):
        if args.ids is None:
            return None
        seen_ids = set()
        with open(args.ids) as f:
            for line in f:
                line = line.strip("\n")
                seen_id = line.partition("\t")[0]
                seen_ids.add(seen_id)
            
        return SeenIdsFilterTool(seen_ids, args.exclude_ids)

    def __init__(self, seen_ids, exclude_ids):
        self.seen_ids = seen_ids
        self.exclude_ids = exclude_ids

    def at_start(self, state):
        id = state.id
        reporter = state.reporter
        try:
            if self.exclude_ids:
                if id in self.seen_ids:
                    return False
                else:
                    reporter.skip(id, "new id")
                    return True
            else:
                if state.id in self.seen_ids:
                    reporter.skip(id, "duplicate id")
                    return True
                else:
                    return False
        finally:
            self.seen_ids.add(id)

class NovelFeaturesFilterTool(FilterTool):
    @staticmethod
    def add_arguments(parser):
        parser.add_argument(
            "--novel",
            action = "store_true",
            help = "only output molecules with new features",
            )
        parser.add_argument(
            "--novel-count",
            metavar = "N",
            type = int,
            default = 1,
            help = "allow up to N occurences of a given feature (default: 1)",
            )
            
    @staticmethod
    def initialize(parser, args):
        if not args.novel:
            return None

        count = args.novel_count
        if count < 1:
            parser.error("--novel-count must be a positive integer")
        return NovelFeaturesFilterTool(count)
    
    def __init__(self, max_count):
        #self.seen_features = set()
        self.max_count = max_count
        self.feature_counter = Counter()

    def at_end(self, state):
        max_count = self.max_count
        counter = self.feature_counter
        if all(counter.get(feature, 0) >= max_count
                   for feature in state.features
                   if "=" not in feature # ignore weighting features
                   ):
            state.reporter.skip(state.id, "no novel features")
            return True
        counter.update(state.features)
        return False
    
########## OpenEye tools 

oe_msg_handler = None

def capture_oe_warnings():
    global oe_msg_handler
    if oe_msg_handler is not None:
        return
    
    from openeye.oechem import OEErrorHandlerImplBase, OEErrorLevelToString, OEThrow
        
    class CaptureOEErrorHandler(OEErrorHandlerImplBase):
        def __init__(self):
            super().__init__()
            self.messages = []
            
        def Msg(self, level, msg):
            self.messages.append(f"{OEErrorLevelToString(level)}: {msg}")

        def Clear(self):
            del self.messages[:]
            super().Clear()

        def __bool__(self):
            return bool(self.messages)
        
    oe_msg_handler = CaptureOEErrorHandler()
    OEThrow.SetHandlerImpl(oe_msg_handler, False)

def oe_standarize_mol(mol):
    if not oechem.OEAddExplicitHydrogens(mol):
        if oe_msg_handler is not None:
            oe_msg_handler.messages.append(
                "WARNING: Unable to add explicit hydrogens"
                )
    oechem.OEAssignAromaticFlags(mol, oechem.OEAroModel_MDL)
    oechem.OEPerceiveChiral(mol)
    return mol
    
def iter_ids_and_oegraphmols(ifs, id_tag):
    from openeye import OEGetSDData

    if oe_msg_handler is not None:
        oe_msg_handler.Clear()
    for molno, mol in enumerate(ifs.GetOEGraphMols(), 1):
        if id_tag is not None:
            id = OEGetSDData(mol, id_tag)
            if not id:
                id = mol.GetTitle()
        else:
            id = mol.GetTitle()
        if not id:
            if id_tag is None:
                die(f"Missing identifier from record #{molno}")
            else:
                die(f"Missing identifier from record #{molno} with id_tag {id_tag!r}")
        mol = oe_standarize_mol(mol)
        yield id, mol
        if oe_msg_handler is not None:
            oe_msg_handler.Clear()

def oe_parse_mol(record, record_format):
    if record_format == "sdf":
        fmt = oechem.OEFormat_SDF
    elif record_format == "smi":
        fmt = oechem.OEFormat_SMI
    else:
        raise AssertionError(record_format)
    
    if oe_msg_handler is not None:
        oe_msg_handler.Clear()
        
    ifs = oechem.oemolistream()
    ifs.SetFormat(fmt)
    assert ifs.openstring(record)
    for mol in ifs.GetOEGraphMols():
        break
    else:
        mol = None
    if mol is not None:
        mol = oe_standarize_mol(mol)
    return mol

# Don't process molecules with a "*" or R-group.
# (This works for both OEChem and RDKit molecules!)
class RealAtomFilterTool(FilterTool):
    @staticmethod
    def initialize(parser, args):
        return RealAtomFilterTool()

    def at_start(self, state):
        for atom in state.mol.GetAtoms():
            if atom.GetAtomicNum() == 0:
                state.reporter.skip(state.id, f"contains atom with atomic num 0")
                return True
        return False
    
class OESingleComponentFilterTool(FilterTool):
    @staticmethod
    def add_arguments(parser):
        parser.add_argument(
            "--multiple-components",
            action = "store_true",
            help = "keep molecules with multiple components (default is to skip them)",
            )
    @staticmethod
    def initialize(parser, args):
        if args.multiple_components:
            return None
        return OESingleComponentFilterTool()

    def __init__(self):
        from openeye.oechem import OEDetermineComponents
        self.OEDetermineComponents = OEDetermineComponents
        
    def at_start(self, state):
        num_components, components = self.OEDetermineComponents(state.mol)
        if num_components != 1:
            state.reporter.skip(state.id, f"number of components = {num_components}")
            return True
        return False

## OEChem feature tools

class OEWarningFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--parse-warnings",
            action = "store_true",
            help = "Toolkit parser warning messages feature tool",
            )
        
    @staticmethod
    def initialize(parser, args):
        if not args.parse_warnings:
            return
        capture_oe_warnings()
        return OEWarningFeatureTool()

    def add_features(self, state):
        num_bad_stereo = 0
        for msg in oe_msg_handler.messages:
            if "Unsupported Sgroup information ignored" in msg:
                state.add_feature("oe_warn_Sgroup")
            elif "Stereochemistry corrected on atom" in msg:
                num_bad_stereo += 1
                state.add_feature("oe_warn_AS")
            elif "Unable to add explicit hydrogens" in msg:
                state.add_feature("oe_warn_AddHs")
            elif "Problem parsing SMILES" in msg:
                state.add_feature("oe_err_smi")
                break
            elif "Problem parsing SMILES" in msg:
                raise AssertionError("OE", msg)

        if 2 <= num_bad_stereo <= 5:
            state.add_feature("oe_warn_AS_2_5")
        if 6 <= num_bad_stereo:
            state.add_feature("oe_warn_AS_6_")
    
class OEAtomCountFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--atom-count",
            action = "store_true",
            help = "Include total atom count as a weighted feature",
            )
        parser.add_argument(
            "--no-atom-count",
            action = "store_true",
            help = "Do not include atom count even if --atom-count specified",
            )
        
    @staticmethod
    def initialize(parser, args):
        if args.no_atom_count:
            return None
        if not args.atom_count:
            return None
        return OEAtomCountFeatureTool()

    def add_features(self, state):
        num_atoms = state.mol.NumAtoms()
        state.add_feature(f"oe_natoms={num_atoms}")

            
## class OEUnspecifiedChiralAtomsFeatureTool(FeatureTool):
##     @staticmethod
##     def add_arguments(parser):
##         add_default_feature_argument(
##             parser,
##             "--unspecified-chiral-atoms",
##             action = "store_true",
##             help = "Unspecified chiral atoms feature tool",
##             )

##     @staticmethod
##     def initialize(parser, args):
##         if args.unspecified_chiral_atoms:
##             return OEUnspecifiedChiralAtomsFeatureTool()
##         return None

##     def add_features(self, id, mol, features):
##         unspec_chirals = [a for a in mol.GetAtoms()
##                               if a.IsChiral() and not a.HasStereoSpecified()]
##         features.add("oe_uCA")
##         if 2 <= len(unspec_chirals) <= 4:
##             features.add("oe_uCA_2_4")
##         elif 5 <= len(unspec_chirals) <= 10:
##             features.add("oe_uCA_5_10")
##         elif 11 <= len(unspec_chirals):
##             features.add("oe_uCA_11_")

##         ring_chirals = [a for a in unspec_chirals if a.IsInRing()]
##         if ring_chirals:
##             features.add("oe_urCA")
##             if 2 <= len(ring_chirals) <= 3:
##                 features.add("oe_urCA_2_3")
##             if 4 <= len(ring_chirals):
##                 features.add("oe_urCA_4")

## class OESpecifiedChiralAtomsFeatureTool(FeatureTool):
##     @staticmethod
##     def add_arguments(parser):
##         add_default_feature_argument(
##             parser,
##             "--specified-chiral-atoms",
##             action = "store_true",
##             help = "Specified chiral atoms feature tool",
##             )
        
##     @staticmethod
##     def initialize(parser, args):
##         if args.specified_chiral_atoms:
##             return OESpecifiedChiralAtomsFeatureTool()
##         return None

##     def add_features(self, id, mol, features):
##         chiral_atoms = [a for a in mol.GetAtoms()
##                             if a.IsChiral() and a.HasStereoSpecified()]
##         if chiral_atoms:
##             features.add("oe_CA")
##             if 2 <= len(chiral_atoms) <= 4:
##                 features.add("oe_CA_2_4")
##             elif 5 <= len(chiral_atoms) <= 10:
##                 features.add("oe_CA_5_10")
##             elif 11 <= len(chiral_atoms):
##                 features.add("oe_CA_11_")

##             ring_chirals = [a for a in chiral_atoms if a.IsInRing()]
##             if ring_chirals:
##                 features.add("oe_RCA")
##                 if 2 <= len(ring_chirals) <= 3:
##                     features.add("oe_RCA_2_3")
##                 if 4 <= len(ring_chirals):
##                     features.add("oe_RCA_4")
        

## class OEUnspecifiedChiralBondsFeatureTool(FeatureTool):
##     @staticmethod
##     def add_arguments(parser):
##         add_default_feature_argument(
##             parser,
##             "--unspecified-chiral-bonds",
##             action = "store_true",
##             help = "Unspecified chiral bonds feature tool",
##             )

##     @staticmethod
##     def initialize(parser, args):
##         if args.unspecified_chiral_bonds:
##             return cls()
##         return None

##     def add_features(self, id, mol, features):
##         # From openff-toolkit/openff/toolkit/utils/toolkits.py
##         unspec_db = [b for b in mol.GetBonds()
##                          if b.IsChiral() and not b.HasStereoSpecified()]

##         if unspec_db:
##             features.add("oe_uCB")
##             if 2 <= len(unspec_db) <= 4:
##                 features.add("oe_uCB_2_4")
##             if 5 <= len(unspec_db) <= 8:
##                 features.add("oe_uCB_5_8")
##             if 9 <= len(unspec_db):
##                 features.add("oe_uCB_9_")

def oe_get_cached_topology(wrapper, state):
    if "oe_topology" not in state.cache:
        state.cache["oe_topology"] = oe_get_topology(wrapper, state)
    return state.cache["oe_topology"]

def oe_get_topology(wrapper, state):
    from openff.toolkit.utils import UndefinedStereochemistryError

    mol = state.mol
    features = state.features

    #with capture_stderr() as msgs:
    try:
        obj = wrapper.from_object(mol, allow_undefined_stereo=False)
    except UndefinedStereochemistryError as err:
        for line in str(err).splitlines():
            if "OEMol has unspecified stereochemistry." in line:
                continue
            
            if "Problematic atoms" in line:
                state.add_feature("oe_off_undef_stereo_atom")
                continue
            if line.startswith("Atom atomic num:"):
                continue
            if line.startswith("bond order: "):
                continue

            if "Problematic bonds are:" in line:
                state.add_feature("oe_off_undef_stereo_bond")
                continue
            
            ## if "Undefined chiral centers are:" in line:
            ##     continue
            ## if "Bonds with undefined stereochemistry are" in line:
            ##     continue
            ## if "- Bond" in line and "(atoms " in line:
            ##     state.add_feature("oe_off_undef_stereo_bond")
            ##     ## terms = line.split()
            ##     ## s = terms[-1].replace("-","_").strip("()")
            ##     ## state.add_feature(f"o_uBS_{s}")
            ##     continue
            ## if "- Atom" in line and "(index" in line:
            ##     state.add_feature("oe_off_undef_stereo_atom")
            ##     ## terms = line.split()
            ##     ## s = terms[2]
            ##     ## state.add_feature(f"oe_uAS_{s}")
            ##     continue
            raise AssertionError(line) # Don't know what this is.
        return None

    features.add("oe_openff_good")
    return obj

class OEOpenFFFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--openff",
            action = "store_true",
            help = "convert the molecule to an OpenFF Molecule and record problems",
            )

    @staticmethod
    def initialize(parser, args):
        if not args.openff:
            return None
        return OEOpenFFFeatureTool()

    def __init__(self):
        from openff.toolkit.utils import OpenEyeToolkitWrapper
        self._wrapper = OpenEyeToolkitWrapper()

    def add_features(self, state):
        oe_get_cached_topology(self._wrapper, state)

            
class OEPatternDefs:
    def __init__(self, pattern_defs, prefix, matchers):
        self.pattern_defs = pattern_defs
        self.prefix = prefix
        self.matchers = matchers

    def add_features(self, state):
        id, mol = state.id, state.mol

        saved_isotopes = None
        
        prefix = self.prefix
        counts = {}
        for (lineno, matcher_type, matcher_info) in self.matchers:
            if matcher_type == "count":
                pattern_name, matcher, is_unique = matcher_info
                counts[pattern_name] = sum(1 for match in matcher.Match(mol, is_unique))
            elif matcher_type == "tag":
                if saved_isotopes is None:
                    saved_isotopes = [(atom, atom.GetIsotope()) for atom in mol.GetAtoms()]
                matcher, isotope = matcher_info
                matcher.tag(mol, isotope)
            else:
                raise AssertionError(matcher_type)
        
        try:
            for (lineno, feature_name, feature_expr, code) in self.pattern_defs.features:
                if eval(code, None, counts):
                    state.add_feature(prefix + feature_name)
        except ZeroDivisionError as err:
            state.reporter.unexpected_error(
                id,
                f"ZeroDivisionError in {feature_name!r}: {feature_expr!r}",
                )
            state.add_feature(prefix + f"divide_by_zero_{feature_name}")

        if saved_isotopes is not None:
            for atom, isotope in saved_isotopes:
                atom.SetIsotope(isotope)
            
            
class OEPatternTagger:
    def __init__(self, matcher):
        self.matcher = matcher
    def tag(self, mol, isotope):
        for m in self.matcher.Match(mol):
            for a in m.GetTargetAtoms():
                a.SetIsotope(isotope)
            
class OEMatcher:
    def IsValid(self):
        return True
    
    def SetMaxMatches(self, n):
        pass

    def Match(self, mol, is_unique):
        raise NotImplementedError

    def tag(self, mol, isotope):
        for atom in self.Match(mol, False):
            atom.SetIsotope(isotope)

class OEMatchChiralAtoms(OEMatcher):
    def Match(self, mol, is_unique):
        return [atom for atom in mol.GetAtoms() if atom.IsChiral()]
    
class OEMatchSpecifiedChiralAtoms(OEMatcher):
    def Match(self, mol, is_unique):
        return [atom for atom in mol.GetAtoms()
                    if atom.IsChiral() and atom.HasStereoSpecified()]

class OEMatchUnspecifiedChiralAtoms(OEMatcher):
    def Match(self, mol, is_unique):
        return [atom for atom in mol.GetAtoms()
                    if atom.IsChiral() and not atom.HasStereoSpecified()]

class _OEBondTagger:
    def tag(self, mol, isotope):
        for bond in self.Match(mol, False):
            bond.GetBgn().SetIsotope(isotope)
            bond.GetEnd().SetIsotope(isotope)

class OEMatchChiralBonds(_OEBondTagger, OEMatcher):
    def Match(self, mol, is_unique):
        return [bond for bond in mol.GetBonds() if bond.IsChiral()]


class OEMatchSpecifiedChiralBonds(_OEBondTagger, OEMatcher):
    def Match(self, mol, is_unique):
        return [bond for bond in mol.GetBonds()
                    if bond.IsChiral() and bond.HasStereoSpecified()]
    
class OEMatchUnspecifiedChiralBonds(_OEBondTagger, OEMatcher):
    def Match(self, mol, is_unique):
        return [bond for bond in mol.GetBonds()
                    if bond.IsChiral() and not bond.HasStereoSpecified()]

def _get_chiral_CdC(mol):
    return [
        bond 
        for bond in mol.GetBonds() if (
            bond.IsChiral() and
            bond.GetBgn().GetAtomicNum() == 6 and
            bond.GetEnd().GetAtomicNum() == 6 and
            bond.GetIntType() == 2
            )
            ]
                
class OEMatchDefCdC(_OEBondTagger, OEMatcher):
    def Match(self, mol, is_unique):
        return [bond for bond in _get_chiral_CdC(mol)
                    if bond.HasStereoSpecified(oechem.OEBondStereo_CisTrans)]
    
class OEMatchUndefCdC(_OEBondTagger, OEMatcher):
    def Match(self, mol, is_unique):
        return [bond for bond in _get_chiral_CdC(mol)
                    if not bond.HasStereoSpecified(oechem.OEBondStereo_CisTrans)]

_oe_CdC_pat = None
def _get_oe_CdC_pat():
    global _oe_CdC_pat
    if _oe_CdC_pat is None:
        _oe_CdC_pat = oechem.OESubSearch("*-[#6X3]=[#6X3]-*")
    return _oe_CdC_pat

class _OEQuadTagger:
    def Match(self, mol, is_unique):
        raise NotImplementedError
    
    def tag(self, mol, isotope):
        for (a1, a2, a3, a4) in self.Match(mol, True):
            a1.SetIsotope(isotope)
            a2.SetIsotope(isotope)
            a3.SetIsotope(isotope)
            a4.SetIsotope(isotope)
        
class OEMatchUndefCdCUndefStereo(_OEQuadTagger):
    def Match(self, mol, is_unique):
        pat = _get_oe_CdC_pat()
        atom_matches = []
        for m in pat.Match(mol, True):
            b1, b2, b3 = list(m.GetTargetBonds())
            if b2.IsChiral() and not b2.HasStereoSpecified(oechem.OEBondStereo_CisTrans):
                continue
            a1, a2, a3, a4 = atoms = list(m.GetTargetAtoms())
            stereo = b2.GetStereo([a1, a4], oechem.OEBondStereo_CisTrans)
            if stereo == oechem.OEBondStereo_Undefined:
                atom_matches.append(atoms)
        return atom_matches

class OEMatchUndefCdCDefStereo(_OEQuadTagger):
    def Match(self, mol, is_unique):
        pat = _get_oe_CdC_pat()
        atom_matches = []
        for m in pat.Match(mol, True):
            b1, b2, b3 = list(m.GetTargetBonds())
            if b2.IsChiral() and not b2.HasStereoSpecified(oechem.OEBondStereo_CisTrans):
                continue
            a1, a2, a3, a4 = atoms = list(m.GetTargetAtoms())
            stereo = b2.GetStereo([a1, a4], oechem.OEBondStereo_CisTrans)
            if stereo != oechem.OEBondStereo_Undefined:
                atom_matches.append(atoms)
        return atom_matches

class OEMatchDefCdCUndefStereo(_OEQuadTagger):
    def Match(self, mol, is_unique):
        pat = _get_oe_CdC_pat()
        atom_matches = []
        for m in pat.Match(mol, True):
            b1, b2, b3 = list(m.GetTargetBonds())
            if not (b2.IsChiral() and b2.HasStereoSpecified(oechem.OEBondStereo_CisTrans)):
                continue
            a1, a2, a3, a4 = atoms = list(m.GetTargetAtoms())
            stereo = b2.GetStereo([a1, a4], oechem.OEBondStereo_CisTrans)
            if stereo == oechem.OEBondStereo_Undefined:
                atom_matches.append(atoms)
        return atom_matches

class OEMatchDefCdCDefStereo(_OEQuadTagger):
    def Match(self, mol, is_unique):
        pat = _get_oe_CdC_pat()
        atom_matches = []
        for m in pat.Match(mol, True):
            b1, b2, b3 = list(m.GetTargetBonds())
            if not (b2.IsChiral() and b2.HasStereoSpecified(oechem.OEBondStereo_CisTrans)):
                continue
            a1, a2, a3, a4 = atoms = list(m.GetTargetAtoms())
            stereo = b2.GetStereo([a1, a4], oechem.OEBondStereo_CisTrans)
            if stereo != oechem.OEBondStereo_Undefined:
                atom_matches.append(atoms)
        return atom_matches
    

    
_special_oe_matchers = {
    "<chiral_atoms>": OEMatchChiralAtoms,
    "<specified_chiral_atoms>": OEMatchSpecifiedChiralAtoms,
    "<unspecified_chiral_atoms>": OEMatchUnspecifiedChiralAtoms,
    "<chiral_bonds>": OEMatchChiralBonds,
    "<specified_chiral_bonds>": OEMatchSpecifiedChiralBonds,
    "<unspecified_chiral_bonds>": OEMatchUnspecifiedChiralBonds,

    ## XXXX These don't work.
    "<def_CdC>": OEMatchDefCdC,
    "<undef_CdC>": OEMatchUndefCdC,
    
    "<def_CdC_def_stereo>": OEMatchDefCdCDefStereo,
    "<def_CdC_undef_stereo>": OEMatchDefCdCUndefStereo,
    "<undef_CdC_def_stereo>": OEMatchUndefCdCDefStereo,
    "<undef_CdC_undef_stereo>": OEMatchUndefCdCUndefStereo,
    }
    
            
def compile_oe_pattern_defs(pattern_defs, prefix=None):
    from openeye.oechem import OESubSearch
    
    if prefix is None:
        prefix = "oe_"

    matchers = []
    
    for (lineno, tag_pattern, tag_isotope) in pattern_defs.tags:
        special_matcher = _special_oe_matchers.get(tag_pattern, None)
        if special_matcher is None:
            matcher = OESubSearch(tag_pattern)
            if not matcher.IsValid():
                die(f"Cannot parse SMARTS on line {lineno}: {tag_pattern!r}")
            tag_matcher = OEPatternTagger(matcher)
        else:
            tag_matcher = special_matcher()
        matchers.append( (lineno, "tag", (tag_matcher, tag_isotope)) )
    
    for (lineno, pattern_name, count_pattern, pattern_options) in pattern_defs.patterns:
        special_matcher = _special_oe_matchers.get(count_pattern, None)
        if special_matcher is None:
            matcher = OESubSearch(count_pattern)
            if not matcher.IsValid():
                die(f"Cannot parse {pattern_name!r} SMARTS on line {lineno}: {count_pattern!r}")
        else:
            matcher = special_matcher()
        
        max_num_matches = 1024
        is_unique = False
        for (opt_name, opt_value) in pattern_options:
            if opt_name == "unique":
                is_unique = True
            elif opt_name == "limit":
                matcher.SetMaxMatches(opt_value)
            else:
                raise AssertionError(opt_name)
        
        matchers.append( (lineno, "count", (pattern_name, matcher, is_unique) ) )

    matchers.sort()
    
    return OEPatternDefs(pattern_defs, prefix, matchers)

class OEPatternFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_feature_argument(
            parser,
            "--patterns",
            metavar = "FILENAME",
            help = "substructure pattern match definitions",
            )
        parser.add_argument(
            "--pattern-prefix",
            metavar = "STR",
            help = "prefix to add to the match names (default: 'oe_')",
            )

    @staticmethod
    def initialize(parser, args):
        if not args.patterns:
            return None
        pattern_defs = load_pattern_defs(args.patterns)
        return compile_oe_pattern_defs(pattern_defs, args.pattern_prefix)


##
def _get_oefp_bits(fp):
    bits = []
    i = fp.FirstBit()
    while i != -1:
        bits.append(i)
        i = fp.NextBit(i)
    return bits
    
class OECircularFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_feature_argument(
            parser,
            "--circular", action="store_true",
            help = "include circular fingerprint features")

    @staticmethod
    def initialize(parser, args):
        if not args.circular:
            return None
        
        from openeye.oegraphsim import (
            OEFPAtomType_DefaultCircularAtom,
            OEFPBondType_DefaultCircularBond,
        )
        return OECircularFeatureTool(
            8192,
            0, 3,
            OEFPAtomType_DefaultCircularAtom,
            OEFPBondType_DefaultCircularBond)

    def __init__(self, num_bits, min_radius, max_radius, atom_flags, bond_flags):
        self.num_bits = num_bits
        assert min_radius <= max_radius
        #self.min_radius = min_radius
        #self.max_radius = max_radius
        self.atom_flags = atom_flags
        self.bond_flags = bond_flags
        self._fp = oegraphsim.OEFingerPrint()
        self._radii = list(range(min_radius, max_radius+1))

        from openeye.oegraphsim import OEMakeCircularFP
        self.OEMakeCircularFP = OEMakeCircularFP
        
    def add_features(self, state):
        OEMakeCircularFP = self.OEMakeCircularFP
        fp = self._fp
        atom_flags = self.atom_flags
        bond_flags = self.bond_flags
        features = state.features
        
        for r in self._radii:
            OEMakeCircularFP(fp, state.mol, 8192, r, r, atom_flags, bond_flags)
            bits = _get_oefp_bits(fp)
            features.update(f"oe_CR{r}_{i}" for i in bits)
        
    
####
parser = argparse.ArgumentParser(
    description = "find a minimal set of diverse molecules in feature spaces",
    allow_abbrev = False,
    )

parser.add_argument(
    "--version",
    action = "version",
    version = f'%(prog)s {__version__}',
    )


subparsers = parser.add_subparsers()

openeye_filter_tools = [
    SeenIdsFilterTool,
    RealAtomFilterTool,
    OESingleComponentFilterTool,
    NovelFeaturesFilterTool,
    ]

openeye_feature_tools = [
    OEWarningFeatureTool,
    OEAtomCountFeatureTool,
    OEOpenFFFeatureTool,
    ## OEUnspecifiedChiralAtomsFeatureTool,
    ## OESpecifiedChiralAtomsFeatureTool,
    ## OEUnspecifiedChiralBondsFeatureTool,
    OEPatternFeatureTool,
    OECircularFeatureTool,
    ]

openeye_parser = subparsers.add_parser(
    "openeye",
    help = "use OpenEye's OEChem to identify features",
    )
openeye_parser.set_defaults(
    feature_flags = [],
    default_feature_flags = [],
    )

add_id_tag_argument(openeye_parser)
add_default_argument(openeye_parser)
for tool in (openeye_filter_tools + openeye_feature_tools):
    tool.add_arguments(openeye_parser)

add_trace_argument(openeye_parser)
add_quiet_argument(openeye_parser)
add_description_argument(openeye_parser)
add_output_argument(openeye_parser)
add_filename_argument(openeye_parser)

    

def openeye_command(parser, args):
    from openeye.oechem import OEGetSDData, oemolistream
    
    ifs = oemolistream(args.filename)

    if not ifs.IsValid():
        die(f"Cannot open input file {args.filename!r}")

    filter_tools = []
    for config in openeye_filter_tools:
        filter_tool = config.initialize(parser, args)
        if filter_tool is not None:
            filter_tools.append(filter_tool)

    feature_tools = []
    for config in openeye_feature_tools:
        feature_tool = config.initialize(parser, args)
        if feature_tool is not None:
            feature_tools.append(feature_tool)

        
    outfile = open_output(args.output)
    reporter = get_reporter(args.quiet)
    
    tracer = get_tracer(args.trace)
    description_logger = get_description_logger(parser, args.description)
    
    for id, mol in iter_ids_and_oegraphmols(ifs, args.id_tag):
        state = State(id, mol, reporter,
                          description_logger = description_logger)
        
        if any(filter_tool.at_start(state) for filter_tool in filter_tools):
            continue
        
        state.add_feature("oe_parse") # OEChem can parse it

        for feature_tool in feature_tools:
            with tracer.using_state(state):
                feature_tool.add_features(state)

        if any(filter_tool.at_end(state) for filter_tool in filter_tools):
            continue
        
        write_features(outfile, id, state.features)
        

openeye_parser.set_defaults(
    command = openeye_command,
    subparser = openeye_parser,
    )

############ RDKit

class RDMessageHandler:
    def __init__(self):
        self.messages = []
    def __bool__(self):
        return bool(self.messages)
    def Clear(self):
        del self.messages[:]

rd_msg_handler = RDMessageHandler()

def capture_rd_warnings():
    # There's no direct way to get access to the RDKit logs.
    # I'll have RDKit forward its messages to Python,
    # then capture Python's stderr
    Chem.WrapLogs()

def rd_standardize_mol(mol):
    return Chem.AddHs(mol)

def _iter_rdkit_sdf(f, id_tag):
    if id_tag is None:
        id_tag = "_Name"
    suppl = Chem.ForwardSDMolSupplier(f)
    try:
        while 1:
            with capture_stderr() as msgs:
                mol = next(suppl)
            if mol is None:
                # We can't do anothing with this one because there's
                # no way to get access to the id.
                continue
            mol = rd_standardize_mol(mol)
            rd_msg_handler.messages[:] = msgs
            id = mol.GetProp(id_tag)
            yield id, mol

    except StopIteration:
        pass
    finally:
        f.close()
        
def _iter_rdkit_smiles(f):
    from rdkit import Chem
    try:
        for lineno, line in enumerate(f):
            try:
                smiles, id = line.split(None, 1)
            except ValueError:
                die(f"SMILES file line {lineno} not formatted as <SMILES> <whitespace> <id>")
            with capture_stderr() as msgs:
                mol = Chem.MolFromSmiles(smiles)
            if mol is not None:
                mol = rd_standardize_mol(mol)
            rd_msg_handler.messages[:] = msgs
            yield (id.strip(b"\n").decode("utf8"), mol)
    except StopIteration:
        pass
    finally:
        f.close()

def iter_rdkit_ids_and_mols(filename, id_tag):
    s = filename.lower()
    
    f = None
    if s.endswith(".sdf.gz"):
        f = gzip.open(filename, "rb")
        return _iter_rdkit_sdf(f, id_tag)
    elif s.endswith(".sdf"):
        f = open(filename, "rb")
        return _iter_rdkit_sdf(f, id_tag)
        
    if s.endswith(".gz"):
        f = gzip.open(filename, "rb")
        return _iter_rdkit_smiles(f)
    else:
        f = open(filename, "rb")
        return _iter_rdkit_smiles(f)

def rd_parse_mol(record, record_format):
    if record_format == "sdf":
        f = io.BytesIO(record)
        suppl = Chem.ForwardSDMolSupplier(f)
        with capture_stderr() as msgs:
            for mol in suppl:
                break
            else:
                mol = None
            if mol is not None:
                mol = rd_standardize_mol(mol)
        
        rd_msg_handler.messages[:] = msgs
        return mol

    elif record_format == "smi":
        with capture_stderr() as msgs:
            mol = Chem.MolFromSmiles(record)
            if mol is not None:
                mol = rd_standardize_mol(mol)
            rd_msg_handler.messages[:] = msgs
        
        return mol

    raise AssertionError(record_format)
    
#### Filter tools

class RDRealAtomFilterTool(FilterTool):
    @staticmethod
    def initialize(parser, args):
        return RDRealAtomFilterTool()

    def at_start(self, state):
        for atom in state.mol.GetAtoms():
            if atom.GetAtomicNum() == 0:
                state.reporter.skip(state.id, f"contains atom with atomic num 0")
                return True
        return False

class RDSingleComponentFilterTool(FilterTool):
    @staticmethod
    def add_arguments(parser):
        OESingleComponentFilterTool.add_arguments(parser)

    @staticmethod
    def initialize(parser, args):
        if args.multiple_components:
            return None
        return RDSingleComponentFilterTool()

    def at_start(self, state):
        if state.mol is None:
            state.reporter.skip(state.id, "could not parse")
            return True
        components = Chem.GetMolFrags(state.mol)
        num_components = len(components)
        if num_components != 1:
            state.reporter.skip(state.id, f"number of components = {num_components}")
            return True
        return False


#### Feature tools

class RDWarningFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        OEWarningFeatureTool.add_arguments(parser)

    @staticmethod
    def initialize(parser, args):
        if not args.parse_warnings:
            return
        capture_rd_warnings()
        return RDWarningFeatureTool()

    def add_features(self, state):
        for msg in rd_msg_handler.messages:
            if "not removing hydrogen atom without neighbors" in msg:
                state.add_feature("rd_warn_FreeH")
            elif "not removing hydrogen atom with dummy atom neighbors" in msg:
                state.add_feature("rd_warn_DummyH")
            elif "Warning: molecule is tagged as 3D, but all Z coords are zero" in msg:
                state.add_feature("rd_err_3D_zero")
            elif "Explicit valence for atom" in msg:
                ## # Explicit valence for atom # 12 N, 4, is greater than permitted
                ## terms = msg.split()
                ## i = terms.index("#")
                ## # Make something like "N4"
                ## atom_valence = terms[i+2].rstrip(",") + terms[i+3].rstrip(",")
                ## state.add_feature(f"rd_err_valence_{atom_valence}")
                state.add_feature(f"rd_err_valence")
            elif "Can't kekulize mol" in msg:
                # Can't kekulize mol.  Unkekulized atoms: 1 3 5 7 8
                state.add_feature("rd_err_kekulize")
            elif "Could not sanitize molecule ending" in msg:
                state.add_feature("rd_err_sanitize")

            elif ("has specified valence" in msg and
                      "smaller than the drawn valence" in msg):
                state.add_feature("rd_err_drawn_valence_mismatch")
            elif ("Unrecognized radical value" in msg):
                state.add_feature("rd_err_unrecognized_radical")
            elif (
                    msg == 'RDKit ERROR: ' or
                    msg == 'RDKit ERROR: ****' or
                      
                    (msg.startswith('RDKit ERROR: [') # 'RDKit ERROR: [15:33:25] '
                         and msg.endswith('] '))
                      ):
                state.add_feature("rd_err")
            elif (
                    "RDKit ERROR: Post-condition Violation" in msg or
                    "moving to the beginning of the next molecule" in msg
                    ):
                state.add_feature("rd_err")
                break

            elif (
                    "WARNING: Ambiguous stereo: bond(s)" in msg or
                    "WARNING: Charges were rearranged" in msg or
                    "ERROR: Unknown element(s): " in msg or
                    "ERROR: Unknown element '" in msg or
                    "WARNING: Omitted undefined stereo" in msg or
                    "WARNING: Proton(s) added/removed" in msg
                    ):
                # InChI warnings  and errors. Ignore because they
                # don't seem synchronized with the rest of RDKit.
                pass
            else:
                raise AssertionError("What is this error?", msg)

class RDAtomCountFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        OEAtomCountFeatureTool.add_arguments(parser)

    @staticmethod
    def initialize(parser, args):
        if args.no_atom_count:
            return None
        if not args.atom_count:
            return None
        return RDAtomCountFeatureTool()

    def add_features(self, state):
        num_atoms = state.mol.GetNumAtoms()
        state.add_feature(f"rd_natoms={num_atoms}")
    
        
## class RDUnspecifiedChiralAtomsFeatureTool(FeatureTool):
##     pass

## class RDSpecifiedChiralAtomsFeatureTool(FeatureTool):
##     pass

## class RDUnspecifiedChiralBondsFeatureTool(FeatureTool):
##     pass

def rd_get_cached_topology(wrapper, state):
    if "rd_topology" not in state.cache:
        state.cache["rd_topology"] = rd_get_topology(wrapper, state)
    return state.cache["rd_topology"]

def rd_get_topology(wrapper, state):
    from openff.toolkit.utils import UndefinedStereochemistryError
    mol = state.mol
    features = state.features

    #with capture_stderr() as msgs:
    try:
        obj = wrapper.from_object(mol, allow_undefined_stereo=False)
    except UndefinedStereochemistryError as err:
        for line in str(err).splitlines():
            if "Undefined chiral centers are:" in line:
                continue
            if "Bonds with undefined stereochemistry are" in line:
                continue
            if "- Bond" in line and "(atoms " in line:
                state.add_feature("rd_off_undef_stereo_bond")
                ## terms = line.split()
                ## s = terms[-1].replace("-","_").strip("()")
                ## state.add_feature(f"rd_uBS_{s}")
                continue
            if "- Atom" in line and "(index" in line:
                state.add_feature("rd_off_undef_stereo_atom")
                ## terms = line.split()
                ## s = terms[2]
                ## state.add_feature(f"rd_uAS_{s}")
                continue
            raise AssertionError(line) # Don't know what this is.

        return None

    except Chem.AtomValenceException as err:
        # rdkit.Chem.rdchem.AtomValenceException:
        #   Explicit valence for atom # 0 Ge, 6, is greater than permitted
        state.add_feature("rd_off_rd_valence")
        ## msg = str(err)
        ## terms = msg.split()
        ## i = terms.index("#")
        ## atom_symbol = terms[i+2].strip(",")
        ## state.add_feature(f"rd_err_valence_{atom_symbol}")
        return None

    features.add("rd_openff_good")
    return obj

class RDOpenFFFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        OEOpenFFFeatureTool.add_arguments(parser)

    @staticmethod
    def initialize(parser, args):
        if not args.openff:
            return None
        return RDOpenFFFeatureTool()

    def __init__(self):
        from openff.toolkit.utils import (
            MessageException,
            RDKitToolkitWrapper,
            UndefinedStereochemistryError,
        )
        self._wrapper = RDKitToolkitWrapper()

    def add_features(self, state):
        rd_get_cached_topology(self._wrapper, state)


# Work-in-progress
class RDPatternDefs:
    def __init__(self, pattern_defs, prefix, matchers):
        self.pattern_defs = pattern_defs
        self.prefix = prefix
        self.matchers = matchers

    def add_features(self, state):
        id = state.id
        mol = state.mol
        
        prefix = self.prefix
        
        counts = {}
        for (lineno, matcher_type, matcher_info) in self.matchers:
            if matcher_type == "count":
                pattern_name, matcher, is_unique, maxMatches = matcher_info
                counts[pattern_name] = sum(1 for match in mol.GetSubstructMatches(
                    matcher, uniquify=is_unique, maxMatches=maxMatches))
                
            elif matcher_type == "tag":
                matcher, isotope = matcher_info
                matcher.tag(mol, isotope)

            else:
                raise AssertionError(matcher_type)
        
        try:
            for (lineno, feature_name, feature_expr, code) in self.pattern_defs.features:
                if eval(code, None, counts):
                    state.add_feature(prefix + feature_name)
        except ZeroDivisionError:
            sys.stderr.write(f"Divide by zero error in {id!r} - {code!r}\n")
            state.add_feature(prefix + "divide_by_zero")


def compile_rd_pattern_defs(pattern_defs, prefix=None):
    from rdkit import Chem

    if prefix is None:
        prefix = "rd_"
        
    # Compile the SMARTS patterns
    pattern_matchers = []
    for (lineno, pattern_name, pattern_smarts, pattern_options) in pattern_defs.patterns:
        matcher = Chem.MolFromSmarts(pattern_smarts)
        if matcher is None:
            die(f"Cannot parse {pattern_name!r} SMARTS on line {lineno}: {pattern_smarts!r}")
            
        max_num_matches = 1024
        is_unique = False
        for (opt_name, opt_value) in pattern_options:
            if opt_name == "unique":
                is_unique = True
            elif opt_name == "limit":
                max_num_matches = opt_value
            else:
                raise AssertionError(opt_name)
        
        pattern_matchers.append( (pattern_name, matcher, is_unique, max_num_matches) )

    return RDPatternDefs(pattern_defs, prefix, pattern_matchers)

class RDPatternFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_feature_argument(
            parser,
            "--patterns",
            metavar = "FILENAME",
            help = "substructure pattern match definitions",
            )
        parser.add_argument(
            "--pattern-prefix",
            metavar = "STR",
            help = "prefix to add to the match names (default: 'rd_')",
            )
        
    @staticmethod
    def initialize(parser, args):
        if not args.patterns:
            return None
        pattern_defs = load_pattern_defs(args.patterns)
        return compile_rd_pattern_defs(pattern_defs, args.pattern_prefix)

    
class RDCircularFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        OECircularFeatureTool.add_arguments(parser)

    @staticmethod
    def initialize(parser, args):
        if not args.circular:
            return None
        return RDCircularFeatureTool(2)

    def __init__(self, radius):
        self.radius = radius
        from rdkit.Chem.rdMolDescriptors import GetMorganFingerprint
        self.GetMorganFingerprint = GetMorganFingerprint

    def add_features(self, state):
        mol = state.mol
        features = state.features
        fp = self.GetMorganFingerprint(mol, radius = self.radius)
        for k, v in fp.GetNonzeroElements().items():
            state.add_feature(f"rd_M_{k}") # ignoring count
    

            
#### config

rdkit_filter_tools = [
    SeenIdsFilterTool,
    RealAtomFilterTool,
    RDSingleComponentFilterTool,
    NovelFeaturesFilterTool,
    ]

        ## # From _find_undefined_stereo_atoms()
        ## tmp_mol = Chem.Mol(mol)
        ## Chem.AssignStereochemistry(tmp_mol, force=True, flagPossibleStereoCenters=True)

        ## undefined_chiral_atoms = [a for a in tmp_mol.GetAtoms()
        ##                               if a.GetChiralTag() == Chem.ChiralType.CHI_UNSPECIFIED
        ##                               and a.HasProp("_ChiralityPossible")]
        ## if undefined_chiral_atoms:
        ##     features.add("rd_uCA")
        ##     if 2 <= len(undefined_chiral_atoms) <= 4:
        ##         features.add("rd_uCA_2_4")
        ##     elif 5 <= len(undefined_chiral_atoms) <= 10:
        ##         features.add("rd_uCA_5_10")
        ##     elif 11 <= len(undefined_chiral_atoms):
        ##         features.add("rd_uCA_11_")

        ##     ring_chirals = [a for a in undefined_chiral_atoms if a.IsInRing()]
        ##     if ring_chirals:
        ##         features.add("rd_urCA")
        ##         if 2 <= len(ring_chirals) <= 3:
        ##             features.add("rd_urCA_2_3")
        ##         if 4 <= len(ring_chirals):
        ##             features.add("rd_urCA_4")

        ## chiral_atoms = [a for a in tmp_mol.GetAtoms()
        ##                     if a.GetChiralTag() != Chem.ChiralType.CHI_UNSPECIFIED]
        ## if chiral_atoms:
        ##     features.add("rd_CA")
        ##     if 2 <= len(chiral_atoms) <= 4:
        ##         features.add("rd_CA_2_4")
        ##     elif 5 <= len(chiral_atoms) <= 10:
        ##         features.add("rd_CA_5_10")
        ##     elif 11 <= len(chiral_atoms):
        ##         features.add("rd_CA_11_")

        ##     ring_chirals = [a for a in chiral_atoms if a.IsInRing()]
        ##     if ring_chirals:
        ##         features.add("rd_rCA")
        ##         if 2 <= len(ring_chirals) <= 3:
        ##             features.add("rd_rCA_2_3")
        ##         if 4 <= len(ring_chirals):
        ##             features.add("rd_rCA_4")


        ## ## From OpenFF's _find_undefined_stereo_bonds
        ## for bond in tmp_mol.GetBonds():
        ##     bond.SetStereo(Chem.BondStereo.STEREONONE)
        ## Chem.FindPotentialStereoBonds(tmp_mol, cleanIt=True)

        ## num_undefined_bonds = 0
        ## for b, tmp_b in zip(mol.GetBonds(), tmp_mol.GetBonds()):
        ##     if ((tmp_b.GetStereo() == Chem.BondStereo.STEREOANY) and
        ##             (b.GetStereo() in (Chem.BondStereo.STEREOANY, Chem.BondStereo.STEREONONE))):
        ##         num_undefined_bonds += 1

        ## if num_undefined_bonds:
        ##     features.add("rd_uCB")
        ##     if 2 <= num_undefined_bonds <= 4:
        ##         features.add("rd_uCB_2_4")
        ##     if 5 <= num_undefined_bonds <= 8:
        ##         features.add("rd_uCB_5_8")
        ##     if 9 <= num_undefined_bonds:
        ##         features.add("rd_uCB_9_")


        ## if not feature_filter.add_features(features):
        ##     sys.stderr.write(f"id {id!r} has no new features\n")
        ##     continue
    
rdkit_feature_tools = [
    RDWarningFeatureTool,
    RDAtomCountFeatureTool,

    ## RDSpecifiedChiralAtomsFeatureTool,
    ## RDUnspecifiedChiralBondsFeatureTool,
    RDOpenFFFeatureTool,
    RDPatternFeatureTool,
    RDCircularFeatureTool,
]

rdkit_parser = subparsers.add_parser(
    "rdkit",
    help = "use RDKit to identify features",
    )

rdkit_parser.set_defaults(
    feature_flags = [],
    default_feature_flags = [],
    )

add_id_tag_argument(rdkit_parser)
add_default_argument(rdkit_parser)
for tool in (rdkit_filter_tools + rdkit_feature_tools):
    tool.add_arguments(rdkit_parser)

add_trace_argument(rdkit_parser)
add_quiet_argument(rdkit_parser)
add_description_argument(rdkit_parser)
add_output_argument(rdkit_parser)
add_filename_argument(rdkit_parser)

    
def rdkit_command(parser, args):
    from rdkit import Chem
    
    try:
        reader = iter_rdkit_ids_and_mols(args.filename, args.id_tag)
    except OSError as err:
        die(f"Cannot open input file: {err}")

    filter_tools = []
    for config in rdkit_filter_tools:
        filter_tool = config.initialize(parser, args)
        if filter_tool is not None:
            filter_tools.append(filter_tool)

    feature_tools = []
    for config in rdkit_feature_tools:
        feature_tool = config.initialize(parser, args)
        if feature_tool is not None:
            feature_tools.append(feature_tool)

        
    outfile = open_output(args.output)
    reporter = get_reporter(args.quiet)

    tracer = get_tracer(args.trace)
    description_logger = get_description_logger(parser, args.description)
        
    for id, mol in reader:
        state = State(id, mol, reporter,
                          description_logger = description_logger)
        if any(filter_tool.at_start(state) for filter_tool in filter_tools):
            continue

        state.add_feature("rd_parse") # RDKit can parse it


        #num_atoms = mol.GetNumAtoms(onlyExplicit=False)
        #features.add(f"nAtoms={num_atoms}")
        
        for feature_tool in feature_tools:
            with tracer.using_state(state):
                try:
                    feature_tool.add_features(state)
                except Exception as err:
                    reporter.unexpected_error(
                        id, f"failure in {feature_tool}: {err}"
                        )
                    state.add_feature("FeatureFailure_openeye")
                    

        
        if any(filter_tool.at_end(state) for filter_tool in filter_tools):
            continue
        
        write_features(outfile, id, state.features)


rdkit_parser.set_defaults(
    command = rdkit_command,
    subparser = rdkit_parser,
    )
    
######## cross-compare

# Functions to help read SD and SMILES files

def read_ids_and_records(filename, id_tag = None):
    s = filename.lower()

    if s.endswith(".sdf.gz"):
        f = gzip.open(filename, "rb")
        return _iter_sdf_records(f, id_tag)
    elif s.endswith(".sdf"):
        f = open(filename, "rb")
        return _iter_sdf_records(f, id_tag)
        
    if s.endswith(".gz"):
        f = gzip.open(filename, "rb")
        return _iter_smi_records(f)
    else:
        f = open(filename, "rb")
        return _iter_smi_records(f)

class TextRecord:
    def __init__(self, record_format, record):
        self.record_format = record_format
        self.record = record

# Simplistic record tokenizer.
# Doesn't handle the many nuances of the SDF format.

_record_terminator = re.compile(r"""
(                         # If no data items:
  \n
  M\ \ END\s?\n           # 'M  END' on its own line
  [$][$][$][$][^\n]*\n    # followed immediately by a line beginning
                          # with four dollar signs.

) | (                     # = If there are data items:
  \n                      # Two blank lines,
  \r?\n                   # 
  [$][$][$][$][^\n]*\n    # followed by the '$$$$' line.
)""".encode("ascii"), re.X)

def _compile_tag_pattern(tag):
    escaped_tag = re.escape(tag)
    return re.compile(f"\n>.*<{escaped_tag}>.*\n(([^\r\n]|\r[^\n])*)\r?\n".encode("utf8"))
        
def _iter_sdf_records(f, id_tag):
    try:
        if id_tag is not None:
            id_tag_pat = _compile_tag_pattern(id_tag)
        lineno = 1
        prev_block = b""
        while 1:
            next_block = f.read(100_000)
            if not next_block:
                if prev_block:
                    die(f"Incomplete final SDF record at line {lineno}")
                else:
                    return # Reached EOF

            block = prev_block + next_block

            if len(block) > 300_000:
                die("SDF record is too large")

            start = 0
            while 1:
                m = _record_terminator.search(block, start)
                if m is None:
                    break
                end = m.end()
                record = block[start:end]
                if id_tag is None:
                    # Get the first line
                    id = record.partition(b"\n")[0].rstrip(b"\r").decode("utf8")
                else:
                    # Search for the id tag 
                    id_tag_match = id_tag_pat.search(record)
                    if id_tag_match is None:
                        id = None
                    else:
                        id = id_tag_match.group(1).decode("utf8")
                yield id, TextRecord("sdf", record)
                lineno += record.count(b"\n")
                start = end

            prev_block = block[start:]
    finally:
        f.close()

def _iter_smi_records(f):
    try:
        for line in f:
            terms = line.split(None, 1)
            n = len(terms)
            if n == 1:
                yield None, TextRecord("smi", line)
            elif n == 2:
                yield terms[1].rstrip().decode("utf8"), TextRecord("smi", line)
    finally:
        f.close()
 
### cross-compare with chemfp
## def check(filename, id_tag=None):
##     from chemfp import text_toolkit
##     it = read_ids_and_records(filename, id_tag = id_tag)
##     for id1, rec1 in text_toolkit.read_ids_and_molecules(filename, id_tag = id_tag):
##         id2, rec2 = next(it)
##         assert id1 == id2, (id1, id2)
##         assert rec1.record_format == rec2.record_format, (
##             id1, id2, rec1.record_format, rec2.record_format)
##         assert rec1.record == rec2.record, (id1, id2)

##     try:
##         next(it)
##     except StopIteration:
##         pass
##     else:
##         raise AssertionError
        
####

class XCompareCountsFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--counts",
            action = "store_true",
            help = "Compare atom and bond counts",
            )
        parser.add_argument(
            "--no-atom-count",
            action = "store_true",
            help = "Do not include atom counts as weighted features",
            )
        
    @staticmethod
    def initialize(parser, args):
        if args.counts:
            return XCompareCountsFeatureTool(not args.no_atom_count)

    def __init__(self, include_atom_count):
        self.include_atom_count = include_atom_count
            
    def add_features(self, state):
        # Should have no implicit hydrogens
        oe_num_atoms = state.oe_state.mol.NumAtoms()
        rd_num_atoms = state.rd_state.mol.GetNumAtoms()

        if self.include_atom_count:
            state.add_feature(f"oe_natoms={oe_num_atoms}")
            state.add_feature(f"rd_natoms={rd_num_atoms}")

        if oe_num_atoms == rd_num_atoms:
            state.add_feature("xcmp_natom_ok")
        else:
            state.add_feature("xcmp_natom_bad")
            
        oe_num_bond = state.oe_state.mol.NumBonds()
        rd_num_bonds = state.rd_state.mol.GetNumBonds()

        if oe_num_atoms == rd_num_atoms:
            state.add_feature("xcmp_nbond_ok")
        else:
            state.add_feature("xcmp_nbond_bad")

class XCompareIsomorphicFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--isomorphic",
            action = "store_true",
            help = "compare OpenFF molecules by isomorphism",
            )

    @staticmethod
    def initialize(parser, args):
        if args.isomorphic:
            return XCompareIsomorphicFeatureTool()

    def __init__(self):
        from openff.toolkit.utils import OpenEyeToolkitWrapper, RDKitToolkitWrapper
        self.oe_wrapper = OpenEyeToolkitWrapper()
        self.rd_wrapper = RDKitToolkitWrapper()
        
    def add_features(self, state):
        oe_molecule = oe_get_cached_topology(self.oe_wrapper, state.oe_state)
        rd_molecule = rd_get_cached_topology(self.rd_wrapper, state.rd_state)
        if oe_molecule is None or rd_molecule is None:
            return
        
        try:
            is_isomorphic = oe_molecule.is_isomorphic_with(
                rd_molecule, bond_order_matching=False)
        except Exception as err:
            state.add_feature("xcmp_isomorphism_fail")
            state.reporter.unexpected_error(
                state.id, f"Cannot compare isomorphism: {err}")
            return

        if is_isomorphic:
            state.add_feature("xcmp_isomorphic_ok")
        else:
            state.add_feature("xcmp_isomorphic_err")


class XCompareSmilesFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_default_feature_argument(
            parser,
            "--smiles",
            action = "store_true",
            help = "compare OpenFF generated SMILES",
            )

    @staticmethod
    def initialize(parser, args):
        if args.smiles:
            return XCompareSmilesFeatureTool()
        return None

    def __init__(self):
        from openff.toolkit.utils import OpenEyeToolkitWrapper, RDKitToolkitWrapper
        self.oe_wrapper = OpenEyeToolkitWrapper()
        self.rd_wrapper = RDKitToolkitWrapper()
    
    def add_features(self, state):
        oe_molecule = oe_get_cached_topology(self.oe_wrapper, state.oe_state)
        rd_molecule = rd_get_cached_topology(self.rd_wrapper, state.rd_state)
        if oe_molecule is None or rd_molecule is None:
            return

        # TODO: Move this into its own cached to_molecule function
        oe_smi = self.oe_wrapper.to_smiles(oe_molecule)
        state.add_feature("xcmp_smi_oe_ok")
        try:
            rd_smi = self.rd_wrapper.to_smiles(rd_molecule)
        except AssertionError:
            state.add_feature("xcmp_smi_rd_assert_err")
            return
        state.add_feature("xcmp_smi_rd_ok")
        #sys.stderr.write(f"\nSMILES {state.id!r}\n  {oe_smi}\n  {rd_smi}\n")

        oe_natoms = oechem.OESmilesAtomCount(oe_smi)
        rd_natoms = oechem.OESmilesAtomCount(rd_smi)

        if oe_natoms == rd_natoms:
            state.add_feature("xcmp_smi_ok")
        else:
            state.add_feature("xcmp_smi_err")

        ## TODO: use oe_wrapper to convert rd_molecule to SMILES
        ##  and vice-versa, then compare?

        try:
            rd_oe_smi = self.rd_wrapper.to_smiles(oe_molecule)
        except Chem.AtomValenceException as err:
            state.add_feature("xcmp_smi_rd_oe_err")
            return
        state.add_feature("xcmp_smi_rd_oe_ok")
        try:
            oe_rd_smi = self.oe_wrapper.to_smiles(rd_molecule)
        except Exception as err:
            if "OpenEye atom stereochemistry assumptions failed." in str(err):
                state.add_feature("xcmp_smi_oe_rd_fail")
                return
            raise
        state.add_feature("xcmp_smi_oe_rd_ok")

        if oe_smi == oe_rd_smi:
            # Both generated with OEChem
            state.add_feature("xcmp_smi_oe2_ok")
        else:
            ## TODO:  for some reason this is always incorrect?
            # 
            #sys.stderr.write(f"\nQQOE2 {state.id!r}\n  {oe_smi}\n  {oe_rd_smi}\n")
            state.add_feature("xcmp_smi_oe2_err")
            
        if rd_smi == rd_oe_smi:
            state.add_feature("xcmp_smi_rd2_ok")
        else:
            #sys.stderr.write(f"\nQQRD2 {state.id!r}\n  {rd_smi}\n  {rd_oe_smi}\n")
            state.add_feature("xcmp_smi_rd2_err")
        
        
def _fix_inchi(s):
    for substr in ("/t", "/b", "/m", "/s"):
        i = s.find(substr)
        if i != -1:
            s = s[:i]
    return s
        
class XCompareInChIFeatureTool(FeatureTool):
    @staticmethod
    def add_arguments(parser):
        add_feature_argument(  # Not a default because it doesn't seem useful
            parser,
            "--inchi",
            action = "store_true",
            help = "compare OpenFF generated InChI",
            )

    @staticmethod
    def initialize(parser, args):
        if args.inchi:
            return XCompareInChIFeatureTool()

    def __init__(self):
        from openff.toolkit.utils import OpenEyeToolkitWrapper, RDKitToolkitWrapper
        self.oe_wrapper = OpenEyeToolkitWrapper()
        self.rd_wrapper = RDKitToolkitWrapper()

    def add_features(self, state):
        oe_molecule = oe_get_cached_topology(self.oe_wrapper, state.oe_state)
        rd_molecule = rd_get_cached_topology(self.rd_wrapper, state.rd_state)
        if oe_molecule is None or rd_molecule is None:
            return

        oe_inchi = self.oe_wrapper.to_inchi(oe_molecule)
        state.add_feature("xcmp_inchi_oe_ok")
        try:
            rd_inchi = self.rd_wrapper.to_inchi(rd_molecule)
        except AssertionError:
            state.add_feature("xcmp_inchi_rd_assert_err")
            return
        state.add_feature("xcmp_inchi_rd_ok")

        fixed_oe_inchi = _fix_inchi(oe_inchi)
        fixed_rd_inchi = _fix_inchi(rd_inchi)
        if fixed_oe_inchi == fixed_rd_inchi:
            state.add_feature("xcmp_inchi_ok")
        else:
            sys.stderr.write(f"INCHI {state.id!r}\n  {oe_inchi}\n  {rd_inchi}\n")
            state.add_feature("xcmp_inchi_err")



xcompare_filter_tools = [
    # These are manually initialized
    SeenIdsFilterTool,
    RealAtomFilterTool,
    OESingleComponentFilterTool,
    NovelFeaturesFilterTool,
    ]

xcompare_feature_tools = [
    XCompareCountsFeatureTool,
    XCompareIsomorphicFeatureTool,
    XCompareSmilesFeatureTool,
    XCompareInChIFeatureTool,
    ]
    
xcompare_parser = subparsers.add_parser(
    "xcompare",
    help = "Cross compare OEChem and RDKit via OpenFF",
    )

xcompare_parser.set_defaults(
    feature_flags = [],
    default_feature_flags = [],
    )
add_id_tag_argument(xcompare_parser)
add_default_argument(xcompare_parser)
for tool in (xcompare_filter_tools + xcompare_feature_tools):
    tool.add_arguments(xcompare_parser)

add_trace_argument(xcompare_parser)
add_quiet_argument(xcompare_parser)
add_description_argument(xcompare_parser)
add_output_argument(xcompare_parser)
add_filename_argument(xcompare_parser)


def xcompare_command(parser, args):
    #from chemfp import text_toolkit

    #reader = read_ids_and_molecules(
    reader = read_ids_and_records(
        args.filename,
        id_tag = args.id_tag,
        )

    capture_rd_warnings()
    capture_oe_warnings()

    seen_ids_filter = SeenIdsFilterTool.initialize(parser, args)
    real_atoms_filter = RealAtomFilterTool.initialize(parser, args)
    component_filter = OESingleComponentFilterTool.initialize(parser, args)
    novel_filter = NovelFeaturesFilterTool.initialize(parser, args)
    
    rd_warnings = RDWarningFeatureTool()
    oe_warnings = OEWarningFeatureTool()

    feature_tools = [rd_warnings, oe_warnings]
    for config in xcompare_feature_tools:
        feature_tool = config.initialize(parser, args)
        if feature_tool is not None:
            feature_tools.append(feature_tool)
    

    outfile = open_output(args.output)
    reporter = get_reporter(args.quiet)

    tracer = get_tracer(args.trace)
    description_logger = get_description_logger(parser, args.description)
    
    for recno, (id, text_mol) in enumerate(reader, 1):
        assert id, f"Missing id for record #{recno}"
        state = State(id, text_mol, reporter,
                          description_logger = description_logger)
        if seen_ids_filter is not None and seen_ids_filter.at_start(state):
            continue
        
        state.add_feature("parse")

        with tracer.using_state(state):
            oemol = oe_parse_mol(text_mol.record, text_mol.record_format)

        if oemol is None:
            state.add_feature("oe_parse_err")
        else:
            state.add_feature("oe_parse")
        oe_warnings.add_features(state)
        
        with tracer.using_state(state):
            rdmol = rd_parse_mol(text_mol.record, text_mol.record_format)
            
        if rdmol is None:
            state.add_feature("rd_parse_err")
        else:
            state.add_feature("rd_parse")
        rd_warnings.add_features(state)

        if rdmol is not None and oemol is not None:
            oe_state = State(id, oemol, reporter, features = state.features,
                                 description_logger = description_logger)
            if real_atoms_filter.at_start(oe_state):
                continue
            if component_filter is not None and component_filter.at_start(oe_state):
                continue

            rd_state = State(id, rdmol, reporter, features = state.features,
                                 description_logger = description_logger)

            state.oe_state = oe_state
            state.rd_state = rd_state


            for feature_tool in feature_tools:
                with tracer.using_state(state):
                    try:
                        feature_tool.add_features(state)
                    except Exception as err:
                        reporter.unexpected_error(
                            id, f"failure in {feature_tool}: {err}"
                            )
                        state.add_feature("FeatureFailure_xcompare")


        if novel_filter is not None and novel_filter.at_end(state):
            continue
        
        write_features(outfile, id, state.features)

        
        
xcompare_parser.set_defaults(
    command = xcompare_command,
    subparser = xcompare_parser,
    )
####

def iter_features(infile):
    for lineno, line in enumerate(infile, 1):
        left, tab, right = line.partition("\t")
        if tab != "\t":
            die(f"Not a feature file (missing tab) at line {lineno}")
        yield left, right.split()

def load_features(filename):
    dataset = {}
    with open(filename) as f:
        for id, feature_list in iter_features(f):
            dataset[id] = feature_list
    return dataset

merge_parser = subparsers.add_parser(
    "merge",
    help = "merge two feature files",
    )

merge_parser.add_argument(
    "--missing1",
    metavar = "STR",
    help = "if an id is in filename2 but not filename1 then add this feature",
    )
merge_parser.add_argument(
    "--missing2",
    metavar = "STR",
    help = "if an id is in filename1 but not filename2 then add this feature",
    )
merge_parser.add_argument(
    "--both",
    action = "store_true",
    help = "require an id to be present in both files",
    )

merge_parser.add_argument(
    "--no-new-features",
    action = "store_true",
    help = "don't include new features from the second file",
    )

NovelFeaturesFilterTool.add_arguments(merge_parser)
add_quiet_argument(merge_parser)
add_output_argument(merge_parser)
merge_parser.add_argument("filename1")
merge_parser.add_argument("filename2")

def merge_command(parser, args):

    filter_tools = [filter_tool for filter_tool in [
        NovelFeaturesFilterTool.initialize(parser, args),
        ] if filter_tool is not None]

    dataset1 = load_features(args.filename1)
    dataset2 = load_features(args.filename2)
    missing1 = args.missing1
    missing2 = args.missing2

    include_dataset2_features = not args.no_new_features
    
    result = {}
    
    if args.both:
        for id, features in dataset1.items():
            if id in dataset2:
                result[id] = set(features)
                if include_dataset2_features:
                    result[id].update(dataset2[id])
    else:
        for id1, features1 in dataset1.items():
            result[id1] = set(features1)
            if missing2 is not None:
                if id1 not in dataset2:
                    result[id1].add(missing2)
                    
        if include_dataset2_features:
            for id2, features2 in dataset2.items():
                if id2 in result:
                    result[id2].update(features2)
                else:
                    result[id2] = set(features2)
                    if missing1 is not None:
                        result[id2].add(missing1)
        else:
            unique_features = set()
            for v in result.values():
                unique_features.update(v)
            for id2, features2 in dataset2.items():
                if id2 in result:
                    result[id2].update(features2 & unique_features)
                else:
                    result[id2] = set(features2) & unique_features
                    if missing1 is not None:
                        result[id2].add(missing1)
            

    outfile = open_output(args.output)
    reporter = get_reporter(args.quiet)
    
    for id, features in result.items():
        state = State(id, None, reporter, features = features)
        if any(filter_tool.at_start(state) for filter_tool in filter_tools):
            continue

        if any(filter_tool.at_end(state) for filter_tool in filter_tools):
            continue
            
        write_features(outfile, id, state.features)
            

merge_parser.set_defaults(
    command = merge_command,
    subparser = merge_parser,
    )


####

subtract_parser = subparsers.add_parser(
    "subtract",
    help = "remove features from A which are present in B",
    )

add_output_argument(subtract_parser)
subtract_parser.add_argument("filename1")
subtract_parser.add_argument("filename2")

def subtract_command(parser, args):
    dataset1 = load_features(args.filename1)
    dataset2 = load_features(args.filename2)

    new_dataset = {}

    for id, feature_list in dataset1.items():
        if id not in dataset2:
            new_dataset[id] = feature_list
        else:
            # Don't remove feature weights
            remove_features = set(feature for feature in dataset2[id] if "=" not in feature)
            new_dataset[id] = [feature for feature in feature_list if feature not in remove_features]
            
    outfile = open_output(args.output)
    for id, feature_list in new_dataset.items():
        write_features(outfile, id, feature_list)

subtract_parser.set_defaults(
    command = subtract_command,
    subparser = subtract_parser,
    )

####

minimize_parser = subparsers.add_parser(
    "minimize",
    help = "find a minimial set of features for a feature file",
    )

minimize_parser.add_argument(
    "--weight",
    metavar = "EXPR",
    help = "Python expression defining the per-record weights (default: '1')",
    )

minimize_parser.add_argument(
    "--all",
    dest = "show_all",
    action = "store_true",
    help = "include ids in the output even if not selected",
    )

minimize_parser.add_argument(
    "--timeout",
    metavar = "INT",
    type = int,
    help = "timeout in milliseconds",
    )

minimize_parser.add_argument(
    "--show-model",
    action = "store_true",
    help = "print the model to stdout",
    )

add_quiet_argument(minimize_parser)
add_output_argument(minimize_parser)

minimize_parser.add_argument(
    "filename",
    help = "feature file",
    )


#### Construct a Z3 expression roughly like the following:
##
## (declare-const id1 Bool)
## (declare-const id2 Bool)
##
## (assert (and
##   (or id1 id2 )
##   (or id3 id9 )
## ))
##
## (declare-fun final_sum () Int)
## (assert (= final_sum (+
##   (ite id1 1 0)
##   (ite id2 1 0)
##   (ite id3 1 0)
##   )))
## (minimize final_sum)
## (check-sat)
## (get_model)

class IdInfo:
    def __init__(self, id_var, feature_set):
        self.id_var = id_var
        self.feature_set = feature_set

def minimize_command(parser, args):
    try:
        import z3
    except ImportError as err:
        die(f"Cannot import 'z3': {err}\nUse 'pip install z3-solver' to install it.")


    reporter = get_reporter(args.quiet)
    
    timeout = args.timeout
    if timeout is not None:
        if timeout < 0:
            parser.error("--timeout must be non-negative")
        z3.set_param("timeout", timeout)
        
    if args.weight is None:
        def get_weight(id, weights):
            return 1
    else:
        expr = compile(args.weight, "--weight", "eval")
        def get_weight(id, weights):
            d = weights.copy()
            d["_"] = weights
            d["_features"] = set(name for name, value in weights.items() if value is True)
            d["ID"] = id

            try:
                w = eval(expr, None, d)
            except NameError as err:
                sys.stderr.write(f"Unable to evaluate {args.weight!r} for id {id!r}: {err}\n")
                sys.stderr.write(f"Available names are: {sorted(weights)}\n")
                raise SystemExit(1)
            # TODO: error handling for ZeroDivisionError, etc.

            if not isinstance(w, int):
                sys.stderr.write(f"--weight {args.weight!r} for id {id!r} must return an integer. Got: {w!r}\n")
                raise SystemExit(1)
            return w

    id_to_id_info = {}
    feature_to_id_vars = defaultdict(list)
    total_cost = None

    reporter.status(f"Reading {args.filename!r} ...")
    with open(args.filename) as infile:
        for id, feature_list in iter_features(infile):
            if id in id_to_id_info:
                die(f"Duplicate identifier {id!r} in feature file.")

            # New identifier
            id_var = z3.Bool(id)
            
            # Figure out the features and feature weights.
            weights = {}
            feature_set = set()
            for feature in feature_list:
                if "=" in feature:
                    # Feature weight
                    left, mid, right = feature.partition("=")
                    if not right.isdigit():
                        sys.stderr.write(f"bad feature weight: id {id!r} feature {feature!r}\n")
                        continue
                    weights[left] = int(right)
                elif feature not in feature_set:
                    # Feature
                    feature_set.add(feature)
                    # Keep track of all ids for a given feature.
                    feature_to_id_vars[feature].append(id_var)
                    # All normal features names have a weight of True, which equals 1.
                    weights[feature] = True

            # Figure out the weight for this id
            weight = get_weight(id, weights)

            # Construct the cost function as the sum of the weights.
            cost = z3.If(id_var, weight, 0)
            if total_cost is None:
                total_cost = cost
            else:
                total_cost += cost

            id_to_id_info[id] = IdInfo(id_var, feature_set)

    reporter.status(f"Creating Z3 model ...")
    ##   (or id1 id2 )
    feature_ors = []
    for feature_name, id_vars in feature_to_id_vars.items():
        if len(id_vars) == 1:
            # No need for a Boolean-or
            feature_ors.append(id_vars[0])
        else:
            #print("or-ing", len(id_vars))
            feature_ors.append(z3.Or(*id_vars))

    # (and (or ... ) (or ...) ...)
            
    if not feature_ors:
        # No features
        constraint = None
    elif len(feature_ors) == 1:
        # No need for a Boolean-and
        constraint = feature_ors[0]
    else:
        constraint = z3.And(*feature_ors)

    outfile = open_output(args.output)

    if total_cost is None:
        sys.stderr.write("No feature entries found.\n")
        return

    if constraint is None:
        sys.stderr.write("No features found.\n")
        return

    opt = z3.Optimize()
    opt.add(constraint)
    opt.minimize(total_cost)
    if args.show_model:
        print(opt)

    reporter.status(f"Searching for a solution ...")
    # Z3 catches KeyboardInterrupt and stops the current execution.
    try:
        result = opt.check()
        reporter.status(f"Finished searching. Writing current model.")
        model = opt.model()
        output_z3_matches(outfile, model, result, id_to_id_info, args.show_all)
    except KeyboardInterrupt:
        reporter.status(f"Caught keyboard interrupt! Writing current model.")
        # If there's bad timing then the ^C comes during the output.
        # In that case, try again to write the output.
        model = opt.model()
        output_z3_matches(outfile, model, None, id_to_id_info, args.show_all)


def output_z3_matches(outfile, model, result, id_to_id_info, show_all):
    undefined_ids = []
    union_feature_set = set()

    id_values = {}
    
    for id_name, id_info in id_to_id_info.items():
        val = model[id_info.id_var]
        if val is None:
            undefined_ids.append(id_name)
        elif val:
            id_values[id_name] = 1
            union_feature_set.update(id_info.feature_set)
        else:
            id_values[id_name] = 0

    if str(result) == "sat":
        label = "optimal"
    elif undefined_ids:
        label = "greedy"
    else:
        label = "approximate"
        
    for id_name in undefined_ids:
        id_info = id_to_id_info[id_name]
        new_union = union_feature_set | id_info.feature_set
        if len(new_union) == len(union_feature_set):
            id_values[id_name] = 0
        else:
            id_values[id_name] = 1
            union_feature_set = new_union

    num_true = sum(id_values.values())
    outfile.write(f"Solution: {label} Selected: {num_true}/{len(id_values)}\n")
    num_true = 0
    for id_name in id_to_id_info:
        val = id_values[id_name]
        if show_all or val:
            outfile.write(f"{val}\t{id_name}\n")

        
minimize_parser.set_defaults(
    command = minimize_command,
    subparser = minimize_parser,
    )


####
    

def main(argv=None):
    # if there are extra arguments in the subparser then
    #   args = parser.parse_args(argv)
    # will pass the extra fields back to the main parser,
    # which generates an un-informative top-level error
    # message instead of a more specific subparser error.
    # Instead, I get the known arguments, and send any
    # remaining subarguments to the correct subparser.
    # (See http://stackoverflow.com/questions/25333847/argparse-subcommand-error-message
    # for more details.)
    parsed_args, remaining_argv = parser.parse_known_args(argv)
    if remaining_argv:
        subparser = getattr(parsed_args, "subparser", parser)
        subparser.error("unrecognized arguments: %s" % (" ".join(remaining_argv)))

    # Provide somewhat nicer feedback if no command was given.
    command = getattr(parsed_args, "command", None)
    if command is None:
        parser.error("too few arguments. Use --help for more information.")

    if hasattr(parsed_args, "feature_flags"):
        if (
                # Using the --default flag, or
                parsed_args.default or
                # No features are set
                not any(getattr(parsed_args, flag) for flag in parsed_args.feature_flags)
                ):
            # Set all of the defaults
            for flag in parsed_args.default_feature_flags:
                setattr(parsed_args, flag, True)
        
    parsed_args.command(parsed_args.subparser, parsed_args)

if __name__ == "__main__":
    main()
